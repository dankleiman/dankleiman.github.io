<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>twilio on Dan Kleiman</title>
    <link>/dankleiman.github.io/categories/twilio/index.xml</link>
    <description>Recent content in twilio on Dan Kleiman</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="/dankleiman.github.io/categories/twilio/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>I Hate Voicemail: Straight to SMS with Twilio</title>
      <link>/dankleiman.github.io/2015/09/15/i-hate-voicemail-straight-to-sms-with-twilio</link>
      <pubDate>Tue, 15 Sep 2015 08:02:19 -0400</pubDate>
      
      <guid>/dankleiman.github.io/2015/09/15/i-hate-voicemail-straight-to-sms-with-twilio</guid>
      <description>&lt;p&gt;I hate checking my voicemail. I hate the nagging voicemail icon on my phone that won&amp;rsquo;t be dismissed unless I actually check my voicemail. I hate how listening to a voicemail, capturing relevant information from it, and calling someone back breaks up the normal flow of how I communicate with people all day long: asynchronously, via written communication like email or text.&lt;/p&gt;

&lt;p&gt;These days, when I want to talk to someone, we plan a time to talk and that&amp;rsquo;s fine. But some people still call and leave me a black-box-of-a-voicemail that I have to wade into.&lt;/p&gt;

&lt;p&gt;I needed some way to cut voicemail out of my life&amp;hellip;so I hooked up a Twilio app to handle it for me.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;no-more-voicemail-basic-flow&#34;&gt;No More Voicemail: Basic Flow&lt;/h2&gt;

&lt;p&gt;Instead of having to call in to my voicemail, what if I could get as much relevant info as possible sent right to my phone, right away? There are probably times when actually listening to the message is necessary, so that has to be factored in too.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s the basic flow I set out to create:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Someone calls and I don&amp;rsquo;t answer.&lt;/li&gt;
&lt;li&gt;They are prompted to leave a message as they would normally expect to do.&lt;/li&gt;
&lt;li&gt;The message is recorded.&lt;/li&gt;
&lt;li&gt;The recording is transcribed.&lt;/li&gt;
&lt;li&gt;The transcription is sent to me as a text message, with a link to the recording.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Now I am happy, because I get just about all the information I need from a text. Plus, I have the assurance that if the transcription is incomplete, because voice-to-text is still not perfect, I can listen to the recording.&lt;/p&gt;

&lt;h2 id=&#34;twilio-and-sinatra-for-message-flow&#34;&gt;Twilio and Sinatra for Message Flow&lt;/h2&gt;

&lt;p&gt;To code this up, I used a similar set up to the &lt;a href=&#34;dankleiman.github.io/blog/2015/08/13/sms-to-do-list-with-twilio/&#34;&gt;To Do List app&lt;/a&gt; I built earlier.&lt;/p&gt;

&lt;p&gt;There are three main controller actions in the Sinatra app that the handle an incoming call, record the message, and then send it to me as a text:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# incoming forwarded call
post &#39;/calls&#39; do
  user = User.find_by_phone_number!(params[:ForwardedFrom] || params[:CalledVia])
  Twilio::TwiML::Response.new do |r|
    if greeting = user.messages.current_greeting
      r.Play greeting.recording_url
    else
      r.Say &#39;Please leave a message after the beep.&#39;
    end
    r.Redirect &#39;/record_message&#39;
  end.text
end

# record incoming message
post &#39;/record_message&#39; do
  Twilio::TwiML::Response.new do |r|
    r.Record transcribeCallback: &#39;/messages&#39;, timeout: 30, playBeep: true
  end.text
end

# callback for incoming forwared call
post &#39;/messages&#39; do
  if user = User.find_by_phone_number!(params[:ForwardedFrom] || params[:CalledVia])
    # save recording url, generate pin for message
    message = user.messages.create(pin: Message.generate_pin_for(user), recording_url: params[:RecordingUrl], recording_sid: params[:RecordingSid])
    text = params[:TranscriptionText] || &#39;Unable to transcribe message&#39;
    body = [&amp;quot;FROM: #{params[:Caller] || params[:From]}&amp;quot;,
            &amp;quot;MSG: #{text}&amp;quot;,
            &amp;quot;CALL TO LISTEN: +18001231234&amp;quot;,
            &amp;quot;MSG PIN: #{message.pin}&amp;quot;].join(&amp;quot;\n&amp;quot;)
    client = Twilio::REST::Client.new ENV[&#39;TWILIO_ACCOUNT_ID&#39;], ENV[&#39;TWILIO_AUTH&#39;]
    client.account.messages.create(body: body, to: user.phone_number, from: params[:To])
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s it. Calls get recorded and forwarded to me and the caller leaves a voicemail just like they intended to do.&lt;/p&gt;

&lt;p&gt;Here are a few things I learned with this new Twilio use case.&lt;/p&gt;

&lt;h2 id=&#34;leave-a-greeting&#34;&gt;Leave a Greeting&lt;/h2&gt;

&lt;p&gt;In the &amp;lsquo;/calls&amp;rsquo; block, instead of just the robo-voice that Twilio defaults to prompting the caller to leave a message, I wanted to be able to play a custom greeting.&lt;/p&gt;

&lt;p&gt;When you use the Record verb in Twilio, they will save the recording for you, so I just needed to save the url that points to that resource and the unique id of the recording, in case I want to go back and clean it up later.&lt;/p&gt;

&lt;p&gt;To allow for a custom greeting, I built a separate flow to actually record the outgoing greeting. When I call to check my message, I get a prompt that allows me to record a new greeting.&lt;/p&gt;

&lt;p&gt;To play the greeting to my callers, I then looking up the number the call has been forwarded from and play the custom greeting if there is one.&lt;/p&gt;

&lt;h2 id=&#34;skinny-controllers-really-skinny&#34;&gt;Skinny Controllers, Really Skinny&lt;/h2&gt;

&lt;p&gt;As I was building out the custom greeting, I ran into a timeout issue when playing the greeting and recording the call in the same action.&lt;/p&gt;

&lt;p&gt;I have to look into this more, but Twilio seems to have a really small size limit on the response. Super small controller actions as a constraint makes me think that any complex application logic is going to lots of extra controller actions.&lt;/p&gt;

&lt;p&gt;Whatever my next project is, I&amp;rsquo;ll need to think about the best design to keep the Sinatra app from being tons of seeming unrelated actions.&lt;/p&gt;

&lt;h2 id=&#34;transcription-callback&#34;&gt;Transcription Callback&lt;/h2&gt;

&lt;p&gt;The &amp;lsquo;/messages&amp;rsquo; action, where the app actually sends me the text, is hit as a callback from the transcribeCallback option on Record.&lt;/p&gt;

&lt;p&gt;This is pretty cool, because once the caller records their message, their interaction with the app is done. Twilio then takes the recording, runs the voice-to-text transcription, and posts the attributes of the transcription to &amp;lsquo;/messages&amp;rsquo;.&lt;/p&gt;

&lt;p&gt;From the &lt;a href=&#34;https://www.twilio.com/docs/api/twiml/record&#34;&gt;Twilio API Record docs&lt;/a&gt;, you get the following parameters in the callback:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;TranscriptionSid: The unique 34 character ID of the transcription.&lt;/li&gt;
&lt;li&gt;TranscriptionText: Contains the text of the transcription.&lt;/li&gt;
&lt;li&gt;TranscriptionStatus: The status of the transcription attempt: either &amp;lsquo;completed&amp;rsquo; or &amp;lsquo;failed&amp;rsquo;.&lt;/li&gt;
&lt;li&gt;TranscriptionUrl: The URL for the transcription&amp;rsquo;s REST API resource.&lt;/li&gt;
&lt;li&gt;RecordingSid: The unique 34 character ID of the recording from which the transcription was generated.&lt;/li&gt;
&lt;li&gt;RecordingUrl: The URL for the transcription&amp;rsquo;s source recording resource.&lt;/li&gt;
&lt;li&gt;CallSid: A unique identifier for this call, generated by Twilio.&lt;/li&gt;
&lt;li&gt;AccountSid: Your Twilio account id. It is 34 characters long, and always starts with the letters AC.&lt;/li&gt;
&lt;li&gt;From: The phone number or client identifier of the party that initiated the call. Phone numbers are formatted with a &amp;lsquo;+&amp;rsquo; and country code, e.g. +16175551212 ([E.164][e164] format). Client identifiers begin with the client: URI scheme; for example, for a call from a client named &amp;lsquo;tommy&amp;rsquo;, the From parameter will be client:tommy.&lt;/li&gt;
&lt;li&gt;To: The phone number or client identifier of the called party. Phone numbers are formatted with a &amp;lsquo;+&amp;rsquo; and country code, e.g. +16175551212 ([E.164][e164] format). Client identifiers begin with the client: URI scheme; for example, for a call to a client named &amp;lsquo;jenny&amp;rsquo;, the To parameter will be client:jenny.&lt;/li&gt;
&lt;li&gt;CallStatus: A descriptive status for the call. The value is one of queued, ringing, in-progress, completed, busy, failed or no-answer. See the CallStatus section for more details.&lt;/li&gt;
&lt;li&gt;ApiVersion: The version of the Twilio API used to handle this call. For incoming calls, this is determined by the API version set on the called number. For outgoing calls, this is the API version used by the outgoing call&amp;rsquo;s REST API request.&lt;/li&gt;
&lt;li&gt;Direction: A string describing the direction of the call. inbound for inbound calls, outbound-api for calls initiated via the REST API or outbound-dial for calls initiated by a &lt;Dial&gt; verb.&lt;/li&gt;
&lt;li&gt;ForwardedFrom: This parameter is set only when Twilio receives a forwarded call, but its value depends on the caller&amp;rsquo;s carrier including information when forwarding. Not all carriers support passing this information.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;checking-messages&#34;&gt;Checking Messages&lt;/h2&gt;

&lt;p&gt;Once the message comes through, I get a text with a (hopefully) coherent message, and a fallback option to call in and listen to the record.&lt;/p&gt;

&lt;p&gt;Right now, I have the very &lt;em&gt;cough cough&lt;/em&gt; secure combination of a &amp;ldquo;from&amp;rdquo; phone number and &amp;ldquo;message PIN&amp;rdquo; to authenticate against in order to play the message.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s going to be interesting to think more about securing Twilio-related resources in future projects, but for now, this seems to work.&lt;/p&gt;

&lt;p&gt;So call me. Or don&amp;rsquo;t. I can handle it either way now!&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Text Me When You&#39;re Done: Twilio for Notifications of Long-Running Dev Tasks</title>
      <link>/dankleiman.github.io/2015/08/29/text-me-when-youre-done-twilio-for-notifications-of-long-running-dev-tasks</link>
      <pubDate>Sat, 29 Aug 2015 10:33:48 -0400</pubDate>
      
      <guid>/dankleiman.github.io/2015/08/29/text-me-when-youre-done-twilio-for-notifications-of-long-running-dev-tasks</guid>
      <description>&lt;p&gt;This week at work, we ran into a slight hiccup with one of our larger third-party data syncs. Without going into too much detail, to fix the issue, we had to carefully reproduce data in various states and test fixes that would transform that data back to the correct state &amp;ndash; or for the purpose of this post, &lt;em&gt;I spent a lot of time this week setting things up and waiting for them to run&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Outside of work I&amp;rsquo;ve been continuing to play with Twilio and this morning, with hours of data prep still in front of me, I stumbled across this article on &lt;a href=&#34;https://www.twilio.com/labs/bash/sms&#34;&gt;Sending a Twilio SMS from the Shell&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;Before I get into how this works and what I did, I was also reading some of Patrick McKenzie&amp;rsquo;s old posts on his first Twilio apps. What got me excited this morning was &lt;a href=&#34;http://www.kalzumeus.com/2011/12/19/productizing-twilio-applications/&#34;&gt;something he wrote as an addendum to his TwilioConf talk&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I now consider it my mission statement for all my Twilio projects:&lt;/p&gt;

&lt;blockquote&gt;
&lt;h2 id=&#34;why-i-think-twilio-will-take-over-the-world&#34;&gt;Why I Think Twilio Will Take Over The World&lt;/h2&gt;

&lt;p&gt;(This was not actually in the presentation, because I didn’t have enough time for it, but I sincerely believe it and want to publish it somewhere.)&lt;/p&gt;

&lt;p&gt;I think Twilio is, far and away, the most exciting technology I’ve ever worked with. The world needs cat photos, local coupons, and mobifotosocial games, too, but it needs good telephony systems a lot more, as evidenced by companies paying billions of dollars for them.&lt;/p&gt;

&lt;p&gt;Additionally, Twilio is the nascent, embryonic form of the first Internet that a billion people are going to have access to, because &lt;strong&gt;Twilio turns every phone into a smartphone&lt;/strong&gt;.  The end-game for Zynga’s take-over-the-world vision is the human race slaved to artificial dopamine treadmills.  The endgame for Twilio’s vision is that every $2 handset in Africa is the moral equivalent of an iPhone.  I know which future I want to support.&lt;/p&gt;

&lt;p&gt;Smartphones aren’t smart because of anything on the phones themselves, they’re smart because they speak HTTP and thus get always-on access to a universe of applications which are improving constantly.  Twilio radically reduces the amount of hardware support a phone needs to speak HTTP — it retroactively upgrades every phone in the world to do so.  After that, all you need is the application logic.  And what application logic there is — because the applications live on web servers, they have access to all the wonderful infrastructure built to run the Internet, from APIs that let you get Highly Consequential Data like e.g. weather reports or stock prices or whatever, to easy integration with systems which were never built to have a phone operating as part of them.&lt;/p&gt;

&lt;p&gt;You can’t swing a stick in a business without hitting a problem which a phone application makes great sense for.  I filled up three pages of a notebook with them in just a week after being exposed to Twilio for the first time.  Order status checking for phone/fax/mail orders.  Integrated CRMs for phone customer service representatives.  Flight information.  Bank balances.  Server monitoring.  Appointment reminders. Restaurant reservations.  Local search.  Loyalty programs.  Time card systems.  Retail/service employee support systems.  Shift management.  The list goes on and on and on.&lt;/p&gt;

&lt;p&gt;Seriously, &lt;strong&gt;start writing Twilio apps&lt;/strong&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Thanks, Patrick!&lt;/p&gt;

&lt;h2 id=&#34;twilio-sms-via-shell&#34;&gt;Twilio SMS via Shell&lt;/h2&gt;

&lt;p&gt;Up to this point, I had been thinking of Twilio as a way to tie SMS, either as input or output, to web-based application logic. When I came across the shell script that would also hit Twilio to send SMS, though I realized that chaining a Twilio SMS to a long-running script would allow me to set up and job and just walk away. I&amp;rsquo;ll get a text when it&amp;rsquo;s done. Awesome!&lt;/p&gt;

&lt;p&gt;At it&amp;rsquo;s core, the script is a curl request to the Twilio API:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;RESPONSE=`curl -fSs -u &amp;quot;$ACCOUNTSID:$AUTHTOKEN&amp;quot; -d &amp;quot;From=$CALLERID&amp;quot; -d &amp;quot;To=$PHONE&amp;quot; -d &amp;quot;Body=$MSG&amp;quot; &amp;quot;https://api.twilio.com/2010-04-01/Accounts/$ACCOUNTSID/SMS/Messages&amp;quot; 2&amp;gt;&amp;amp;1`
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The rest of the script takes care of arguments and configuration &amp;ndash; even allowing you to create a separate config file with your Twilio credentials. Pretty sweet to have such a nice neat package! &lt;a href=&#34;https://www.twilio.com/labs/bash/sms&#34;&gt;Here&amp;rsquo;s everything you need to get it running&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;integrating-tasks-with-the-script&#34;&gt;Integrating Tasks with the Script&lt;/h2&gt;

&lt;p&gt;I&amp;rsquo;ve played with a few different alerts so far.&lt;/p&gt;

&lt;p&gt;When I had to load a large file full of sql data, a simple alert when the job was done did the trick:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mysql -u root databasename &amp;lt; some/file.sql; echo &#39;Your table is ready&#39; | ~/twilio-sms 6178675309
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When I was deciding how to break up the file into more manageable smaller files to import, and running around doing errands and walking my dog, just calculating the number of lines took long enough that I piped the result out to the Twilio script and got a text that said 34218:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;wc -l &amp;lt; some/file.sql | ~/twilio-sms 6178675309
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There&amp;rsquo;s nothing earth-shatteringly-amazing technically here. It&amp;rsquo;s really about peace of mind.&lt;/p&gt;

&lt;p&gt;Now, I don&amp;rsquo;t have to keep looking over my shoulder to check if the task is done. Or waste time checking Twitter while I sit at my computer. I can go do more useful things, like finish this blog post, confident that the text notification will be enough to get my attention when the job is done running.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>SMS To Do List with Twilio</title>
      <link>/dankleiman.github.io/2015/08/13/sms-to-do-list-with-twilio</link>
      <pubDate>Thu, 13 Aug 2015 19:45:40 -0400</pubDate>
      
      <guid>/dankleiman.github.io/2015/08/13/sms-to-do-list-with-twilio</guid>
      <description>&lt;p&gt;The other day, I had the pleasure of talking to someone who builds mobile apps with people in developing countries so that community health workers can deliver medical information and collect data.&lt;/p&gt;

&lt;p&gt;As were talking about the technical challenges and logistical challenges (provisioning hundreds of mobile phones and numbers in one go in a country where you have no presence, e.g.), I have a pretty clear mental model of a basic CRUD app distilled down to Android&amp;hellip;and then he said something that changed how I thought about the entire problem:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Some of their programs are limited to SMS-only communication.&lt;/strong&gt; No smartphones, no apps, just text.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;How do you go about guiding someone through a decision tree or collecting form submissions via SMS?&lt;/p&gt;

&lt;p&gt;By coincidence, I had just started reading &lt;a href=&#34;https://pragprog.com/book/dccar2/build-awesome-command-line-applications-in-ruby-2&#34;&gt;a book about building command line apps&lt;/a&gt; and I think that&amp;rsquo;s how the lightbulb went off for me.&lt;/p&gt;

&lt;p&gt;As a developer, I spend a lot of time in front of a command prompt. Many of the more experienced devs I know wouldn&amp;rsquo;t want to touch anything other than the command line to do the bulk of their work &amp;ndash; &lt;strong&gt;and they are navigating an application interface largely built around entering a single text command at a time&lt;/strong&gt;, just like our SMS-constrained health workers.&lt;/p&gt;

&lt;p&gt;In &lt;em&gt;Build Awesome Command-Line Applications in Ruby 2&lt;/em&gt;, one of the first sample projects is a to do list app, from the command line.&lt;/p&gt;

&lt;p&gt;Your basic set up allows you to add items to the list, retrieve the whole list, and mark items as complete. As I was building it out, I also wanted to delete things, because I found that more satisfying.&lt;/p&gt;

&lt;p&gt;Once the idea of an interactive SMS app and the command line to do list fused in my head, I thought it would be fun to write a simple, somewhat interactive program that was all SMS-based.&lt;/p&gt;

&lt;h2 id=&#34;twilio-for-easy-sms-integration&#34;&gt;Twilio for Easy SMS Integration&lt;/h2&gt;

&lt;p&gt;Twilio is a service that allows you to send and receive voice and SMS through their API. They have awesome documentation for a bunch of different languages and great small project tutorials like the one I was about to tackle.&lt;/p&gt;

&lt;p&gt;I stumbled across &lt;a href=&#34;https://www.twilio.com/blog/2014/10/broadcast-text-and-picture-messages-using-ruby-google-spreadsheets-twilio.html&#34;&gt;this one about sending out baby announcements&lt;/a&gt; as I was working and I found it very useful. I was all on board with the google-sheets-as-backend until I got past reading and started trying to write to the sheet. That was too complex for this little project!&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Diving into Twilio, all I had to do was set up a web endpoint to receive messages and write some simple code to generate a reply.&lt;/strong&gt; That&amp;rsquo;s it, one controller action!&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s what I used:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.twilio.com/blog/2014/02/twilio-on-rails-integrating-twilio-with-your-rails-4-app.html&#34;&gt;Set up twilio and Rails&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.twilio.com/blog/2013/10/test-your-webhooks-locally-with-ngrok.html&#34;&gt;Get your local endpoints online with Ngrok&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Write your application logic in the Rails app, just like you were receiving and responding to any normal web request&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;It really is that easy to get started. In all honesty, I did try to poke at the problem from a non-Rails angle for a little bit at first, but I wanted to focus on the Twilio side of things instead. Note to self: I&amp;rsquo;m getting too comfortable with Rails conventions!&lt;/p&gt;

&lt;h2 id=&#34;one-web-endpoint&#34;&gt;One Web Endpoint&lt;/h2&gt;

&lt;p&gt;Here&amp;rsquo;s the controller I wrote to handle incoming messages from the Twilio API and respond with TwiML, Twilio&amp;rsquo;s own version of XML:&lt;/p&gt;

&lt;p&gt;```ruby Message Controller
class MessagesController &amp;lt; ApplicationController
  def index
    initialize_command(params)
    twiml = Twilio::TwiML::Response.new do |r|
      r.Message @command.execute ? @command.response : &amp;lsquo;Sorry something went wrong&amp;rsquo;
    end
    render text: twiml.text
  end&lt;/p&gt;

&lt;p&gt;private&lt;/p&gt;

&lt;p&gt;# build a message and command from incoming params that can be executed to deliver the response
  def initialize_command(message)
    message = Message.new(params)
    @command = begin
      &amp;ldquo;#{message.command.capitalize}Command&amp;rdquo;.constantize.new(message)
    rescue
      HelpCommand.new(message)
    end
  end
end&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;The twilio-ruby gem give you wrappers for the response object, so there&#39;s not a lot of heavy lifting to be done.

Responding to Commands
----------------------

In command line apps, you get a limited number of valid options and a rigid structure to follow when you&#39;re executing commands -- something along the lines of [command] [flags] [arguments].

Here, I wanted to follow a similar convention, at least as far as separating the commands from the message that was being sent.

When I talked to app developer about SMS-based form submission, he said they basically rely on the same thing. **You have to develop a convention for setting apart your commands or your form field identifiers from the data that is being sent.**

We serialize data for web requests all the time, the only difference is that here we need to guide the user into compliance with those conventions because they just have a big text box.

For starters, I decided that I would:

- adopt a convetion of commands coming first, surrounded by * characters on each side, followed by the message
- use &amp;quot;help&amp;quot; command as a catch-all to rescue any user input that didn&#39;t follow the command/message convention
- write helpful, specific prompts for each valid command to ensure that a user always gets a reply and that the reply to invalid commands leads them towards valid ones

To model the command/response structure, I copied a pattern we&#39;ve used often at work: start with a base class that to initialize the command objects, then create subclasses for each command that all know how to &amp;quot;execute&amp;quot; and &amp;quot;respond&amp;quot;.

Inside the &amp;quot;execute&amp;quot; and &amp;quot;response&amp;quot; methods, you can then define unique behavior for each command, but in the controller code above, for example, you simple have to make calls like &amp;quot;command.execute&amp;quot; and &amp;quot;command.response.&amp;quot;

So, for example, when I parse a message that looks like this

&amp;gt;\*new\* add something to the list

a NewCommand object is created. When it&#39;s executed, the new to do list item is saved to the database, and the response is returned, telling the user that their new to do list task has been added.

```ruby New Command
class NewCommand &amp;lt; Command

  def execute
   @item = Item.new(item_options)
   @item.save!
  end

  def response
    &amp;quot;Task added: #{@item.description}&amp;quot;
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If they want to see a list of all their items, they just need to text&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;*list*&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;and the ListCommand responds with a list of their items or a prompt to add something if there aren&amp;rsquo;t any items:&lt;/p&gt;

&lt;p&gt;```ruby List Command
class ListCommand &amp;lt; Command&lt;/p&gt;

&lt;p&gt;def execute
    @list = Item.where(from: @message.from).order(:created_at)
  end&lt;/p&gt;

&lt;p&gt;def response
    if @list.empty?
      &amp;ldquo;Looks like you haven&amp;rsquo;t added anything yet. Create a new item with &lt;em&gt;new&lt;/em&gt; followed by the item description.&amp;rdquo;
    else
      items = []
      @list.each_with_index do |item, index|
        list = &amp;ldquo;#{index + 1}: #{item.description}&amp;rdquo;
        if item.completed_at.present?
          list += &amp;ldquo;, (Completed: #{item.completed_at.to_date})&amp;rdquo;
        end
        items &amp;lt;&amp;lt; list
      end
      items.join(&amp;lsquo;, &amp;lsquo;)
    end
  end&lt;/p&gt;

&lt;p&gt;end
```&lt;/p&gt;

&lt;p&gt;I also built out commands to mark items as complete and remove them from your to do list. Both take integer messages that correspond to the number of the item you get back from the list command.&lt;/p&gt;

&lt;p&gt;So this command would remove the second item on your list:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;*remove* 2&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;debugging-twilio-apps&#34;&gt;Debugging Twilio Apps&lt;/h2&gt;

&lt;p&gt;One of the trickiest parts of even doing this simple app was figuring a good way to debug.&lt;/p&gt;

&lt;p&gt;I &lt;em&gt;think&lt;/em&gt; Twilio has some sandbox features, but at $00.0075 per message, I wasn&amp;rsquo;t too concerned about cost. It was more an issue of figuring out the best way to test input, return values from methods and objects, and visualize the whole request/response cycle, since it is different than the usual web flow I&amp;rsquo;m used to.&lt;/p&gt;

&lt;p&gt;A couple of things I found helpful:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Creating a view to render the response for the controller, so instead of sending the response back to the texter through Twilio, I could view and debug output locally in the browser&lt;/li&gt;
&lt;li&gt;Reading the Twilio error logs &amp;ndash; they have very clear inbound and outbound message logs that give you insight into the headers, parameters, and bodies of the requests and responses in your app&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://apidock.com/rails/ActiveSupport/CoreExtensions/Hash/to_query&#34;&gt;to_query&lt;/a&gt; to turn params hashes into query strings that I could add to my urls in the browser during local testing, especially because this is a typical incoming request query string:&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;/messages?ToCountry=US&amp;amp;ToState=MA&amp;amp;SmsMessageSid=SMe40c71a5a09f1bad9ff702fce90b1d9d&amp;amp;NumMedia=0&amp;amp;ToCity=ROXBURY&amp;amp;FromZip=1096&amp;amp;SmsSid=SMe40c71a5a09f1bad9ff702fce90b1d9d&amp;amp;FromState=MA&amp;amp;SmsStatus=received&amp;amp;FromCity=BOSTON&amp;amp;Body=*list*FromCountry=US&amp;amp;To=8573992266&amp;amp;ToZip=1097&amp;amp;NumSegments=1&amp;amp;MessageSid=SMe40c71a5a09f1bad9ff702fce90b1d9d&amp;amp;AccountSid=AC428abc24c52ac55ff5cd98b68bd6a5e7&amp;amp;From=7811234567&amp;amp;ApiVersion=2010-04-01&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;check-out-the-code&#34;&gt;Check out the Code&lt;/h2&gt;

&lt;p&gt;If you want to see more, &lt;a href=&#34;https://github.com/dankleiman/sms_todo&#34;&gt;here&amp;rsquo;s the code&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>