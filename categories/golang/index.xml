<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>golang on Dan Kleiman</title>
    <link>/dankleiman.github.io/categories/golang/index.xml</link>
    <description>Recent content in golang on Dan Kleiman</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="/dankleiman.github.io/categories/golang/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>GoBridge with Bill Kennedy</title>
      <link>/dankleiman.github.io/2017/02/12/gobridge-with-bill-kennedy</link>
      <pubDate>Sun, 12 Feb 2017 15:18:04 -0500</pubDate>
      
      <guid>/dankleiman.github.io/2017/02/12/gobridge-with-bill-kennedy</guid>
      <description>&lt;p&gt;Last weekend, I had the chance to volunteer at a GoBridge event taught by Bill Kennedy of Ardan Labs. I&amp;rsquo;m trying to make &lt;a href=&#34;dankleiman.github.io/blog/2016/12/29/my-5-strategies-for-learning-go-in-2017/&#34;&gt;2017 my year of learning Go&lt;/a&gt;, so helping out at the event felt like a natural extension and a great way to connect with more people in the Go community.&lt;/p&gt;

&lt;p&gt;Going in with Ruby as my first language, I braced myself for static typing and wanted concurrent programming to bend my brain, but that&amp;rsquo;s not really what happened at all.&lt;/p&gt;

&lt;p&gt;
Before we get into what I actually learned, I urge you to check out all of these related links if you want more background on the GoBridge, the instructor, and the training material:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://golangbridge.org/&#34;&gt;GoBridge&lt;/a&gt; &amp;ndash; the inspiration for the event&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.meetup.com/Framingham-Golang-Meetup/&#34;&gt;Framingham Go&lt;/a&gt; &amp;ndash; the meetup group that organized the event&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/ardanlabs/gotraining#current-schedule&#34;&gt;Ardan Labs Trainings&lt;/a&gt; &amp;ndash; the instructor Bill Kennedy&amp;rsquo;s company that teaches this and other events&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/ardanlabs/gotraining/tree/master/courses/ultimate&#34;&gt;Ultimate Go Training&lt;/a&gt; &amp;ndash; the source material, including design philosophy, practice exercises, and related reading, for the actual workshop&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;Bonus: git clone the Go Training repo above into you $GOPATH, go build it, and it will run as a webserver you can launch locally, browsing all the coure material and links to code samples on the Go Playground.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;And one more caveat: my Tai Chi teacher always talked about the challenges of teaching Tai Chi, which has to be experienced physically, to people who like to do abstract thinking. When someone tends to build a mental model for new information first, it&amp;rsquo;s hard to get them to dive directly into the felt sensations, and as a result, they can come up with some pretty wacky ideas their first time through. He used to say it was like accidentally overhearing two young children describe what they thought sex was like. Of coure, the kids would have wildly inaccurate, innocent, and yet, elaborate ideas about it. And they would be hilariously far off from what the actual experience is like.&lt;/p&gt;

&lt;p&gt;If I head into this post trying to tell you Go is X or Go does Y better than this or that language, I&amp;rsquo;m going to sound like those little kids. This is all new to me and I don&amp;rsquo;t want to just parrot back something I&amp;rsquo;ve heard somewhere. I&amp;rsquo;ll link out to better arguments when it comes to technical detail, but I do want to try to talk about what I continue to find interesting about learning Go.&lt;/p&gt;

&lt;h2 id=&#34;design-software-for-hardware&#34;&gt;Design Software for Hardware&lt;/h2&gt;

&lt;p&gt;We started off the weekend with some &lt;a href=&#34;https://github.com/ardanlabs/gotraining/blob/master/reading/design_guidelines.md&#34;&gt;design guidelines&lt;/a&gt;. Here&amp;rsquo;s the first thing that really jumped out at me:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&amp;ldquo;The most amazing achievement of the computer software industry is its continuing cancellation of the steady and staggering gains made by the computer hardware industry.&amp;rdquo; - Henry Petroski&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Wait, so all that time I haven&amp;rsquo;t been thinking about the relationship between the code I write and the hardware it runs on, I&amp;rsquo;ve actually been contributing to the &amp;ldquo;two steps back&amp;rdquo; phase of technological evolution???&lt;/p&gt;

&lt;p&gt;We explored stack frames and memory allocation and passing values all with the notion that the performance characteristics of the underlying hardware should be factored into the way that your software is written and executed &amp;ndash; a concept with a fantastic name: &lt;strong&gt;Mechanical Sympathy&lt;/strong&gt;. Here&amp;rsquo;s where I take Bill&amp;rsquo;s word for it and I won&amp;rsquo;t try to make the case to you that Go is somehow the best way to achieve this hardware/software balance. But I will say that I am left feeling that the possibility of more powerful and efficient hardware/software unity is intriguing enough to pull me deeper into the story of Go.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Homework:&lt;/strong&gt; Read everything in the &lt;a href=&#34;https://github.com/ardanlabs/gotraining/blob/master/reading/README.md#mechanical-sympathy&#34;&gt;Mechanical Sympathy&lt;/a&gt; section of the training repo.&lt;/p&gt;

&lt;h2 id=&#34;shared-behavior-over-shared-state&#34;&gt;Shared Behavior over Shared State&lt;/h2&gt;

&lt;p&gt;Now, I&amp;rsquo;ll let Bill introduce the other major hurdle I had to overcome with my object-oriented background. Starting around 5 minutes in the video, he explains a typical gotcha that people run into when they switch to Go from an object-oriented language. Even though the slides don&amp;rsquo;t come out in the video, you&amp;rsquo;ll be able to follow the issue.&lt;/p&gt;

&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/7YcLIbG1ekM?t=5m8s&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;Here is &lt;a href=&#34;https://github.com/ardanlabs/gotraining/blob/master/topics/api/composition/grouping/example1/example1.go&#34;&gt;code from the training repo&lt;/a&gt; that illustrates the problem. The comment at the top of the file sums up the problem: &amp;ldquo;This is an example of using type hierarchies with a OOP pattern. This is not something we want to do in Go. Go does not have the concept of sub-typing. All types are their own and the concepts of base and derived types do not exist in Go. This pattern does not provide a good design principle in a Go program.&amp;rdquo;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;
// All material is licensed under the Apache License Version 2.0, January 2004
// http://www.apache.org/licenses/LICENSE-2.0

// This is an example of using type hierarchies with a OOP pattern.
// This is not something we want to do in Go. Go does not have the
// concept of sub-typing. All types are their own and the concepts of
// base and derived types do not exist in Go. This pattern does not
// provide a good design principle in a Go program.
package main

import &amp;quot;fmt&amp;quot;

// Animal contains all the base fields for animals.
type Animal struct {
	Name     string
	IsMammal bool
}

// Speak provides generic behavior for all animals and
// how they speak.
// SMELL - This can&#39;t apply to all animals.
func (a Animal) Speak() {
	fmt.Println(&amp;quot;UGH!&amp;quot;,
		&amp;quot;My name is&amp;quot;, a.Name,
		&amp;quot;, it is&amp;quot;, a.IsMammal,
		&amp;quot;I am a mammal&amp;quot;)
}

// Dog contains everything an Animal is but specific
// attributes that only a Dog has.
type Dog struct {
	Animal
	PackFactor int
}

// Speak knows how to speak like a dog.
func (d Dog) Speak() {
	fmt.Println(&amp;quot;Woof!&amp;quot;,
		&amp;quot;My name is&amp;quot;, d.Name,
		&amp;quot;, it is&amp;quot;, d.IsMammal,
		&amp;quot;I am a mammal with a pack factor of&amp;quot;, d.PackFactor)
}

// Cat contains everything an Animal is but specific
// attributes that only a Cat has.
type Cat struct {
	Animal
	ClimbFactor int
}

// Speak knows how to speak like a cat.
func (c Cat) Speak() {
	fmt.Println(&amp;quot;Meow!&amp;quot;,
		&amp;quot;My name is&amp;quot;, c.Name,
		&amp;quot;, it is&amp;quot;, c.IsMammal,
		&amp;quot;I am a mammal with a climb factor of&amp;quot;, c.ClimbFactor)
}

func main() {

	// SMELL - I can&#39;t create a list of Cats and Dogs using
	// the Animal type. Can&#39;t create a list based on a
	// common set of state.

	// DOES NOT COMPILE

	// Create a list of Animals that know how to speak.
	animals := []Animal{

		// Create a Dog by initializing its Animal parts
		// and then its specific Dog attributes.
		Dog{
			Animal: Animal{
				Name:     &amp;quot;Fido&amp;quot;,
				IsMammal: true,
			},
			PackFactor: 5,
		},

		// Create a Cat by initializing its Animal parts
		// and then its specific Cat attributes.
		Cat{
			Animal: Animal{
				Name:     &amp;quot;Milo&amp;quot;,
				IsMammal: true,
			},
			ClimbFactor: 4,
		},
	}

	// Have the Animals speak.
	for _, animal := range animals {
		animal.Speak()
	}
}

// =============================================================================

// NOTES:

// Smells:
// 	* The Animal type is providing an abstraction layer of reusable state.
// 	* The program never needs to create or solely use a value of type Animal.
// 	* The implementation of the Speak method for the Animal type is a generalization.
// 	* The Speak method for the Animal type is never going to be called.

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Reading the code above, especially for the notes, you can see that the OO mindset of grouping objects based on shared state, and then defining shared behavior for that heirarchy of objects, does not really hold up in Go. Instead, interfaces are defined by shared behavior &amp;ndash; or implementing the same set of methods. If a type implements all the methods defined by the interface, it &lt;em&gt;satisfies&lt;/em&gt; that interface.&lt;/p&gt;

&lt;p&gt;So in our example above, instead of thinking about the shared parent class &amp;ldquo;Animal&amp;rdquo;, Go pushes you to define an interface of &amp;ldquo;things that speak.&amp;rdquo;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;	type Speaker interface {
		Speak()
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In order for a Dog or a Cat or Whatever other type to be a Speaker, it has to implement the Speak method. Sounds cool in theory, right? Here&amp;rsquo;s the first practical example I came across that helped the concept click.&lt;/p&gt;

&lt;p&gt;In &lt;a href=&#34;https://medium.com/go-walkthrough&#34;&gt;Ben Johnson&amp;rsquo;s Go Walkthrough series&lt;/a&gt;, where he explores different packages in the Go standard library, he gives the example of the &lt;code&gt;io.MultiReader&lt;/code&gt; function. The &lt;code&gt;Reader&lt;/code&gt; interface, like our &lt;code&gt;Speaker&lt;/code&gt; interface above, is satisfied when a type can read a stream of bytes.&lt;/p&gt;

&lt;p&gt;In the MultiReader example, Ben asks, &amp;ldquo;what if you are trying to send a POST request and you want to combine the header data you have in memory, with the contents of a file you have on disk?&amp;rdquo; Since you can access the in-memory data and file contents via &lt;code&gt;Read&lt;/code&gt; functions, the info you need can be passed into &lt;code&gt;io.MultiReader&lt;/code&gt; which accepts multiple input readers and concatenates them.&lt;/p&gt;

&lt;p&gt;So in OO land I wouldn&amp;rsquo;t group a file and header data as the same class of object, but if you drill into their behavior given the particular functionality we need, then you can easily see what they have in common.&lt;/p&gt;

&lt;p&gt;At first, seeing this difference in grouping by behavior over state was a little overwhelming - &amp;ldquo;oh gosh, I&amp;rsquo;m going to have to rethink all the heirarchies and abstracts I need to make as I&amp;rsquo;m planning out my code.&amp;rdquo; But again, Bill was very reassuring here. Here was the essence of it:&lt;/p&gt;

&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/mDYCLFE86Po&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;And if you want to see how you solve one problem at a time in your code, go back to the first video in this post for a very elegant example.&lt;/p&gt;

&lt;h2 id=&#34;for-further-training&#34;&gt;For Further Training&lt;/h2&gt;

&lt;p&gt;Check out the full list of &lt;a href=&#34;https://github.com/ardanlabs/gotraining/tree/master/courses&#34;&gt;Ardan Labs courses&lt;/a&gt; along with other recommended Go training materials like &lt;a href=&#34;http://exercism.io/languages/go/about&#34;&gt;Exercism.io&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>My 5 Strategies for Learning Go in 2017</title>
      <link>/dankleiman.github.io/2016/12/29/my-5-strategies-for-learning-go-in-2017</link>
      <pubDate>Thu, 29 Dec 2016 09:29:22 -0500</pubDate>
      
      <guid>/dankleiman.github.io/2016/12/29/my-5-strategies-for-learning-go-in-2017</guid>
      <description>&lt;p&gt;Over the past couple of years, one thing I&amp;rsquo;ve become more and more aware of is the unease and uncertainty of diving into a new project. Not matter what the new X is, I find I always go through the same set of uncomfortable feelings on my initial approach.&lt;/p&gt;

&lt;p&gt;Now, though, I&amp;rsquo;m starting to become familiar enough with this process that &amp;ndash; even though the discomfort doesn&amp;rsquo;t go away in the initial learning stages &amp;ndash; I can embrace it, coexist with it, and forge ahead in learning, because of the strategies I&amp;rsquo;m going to lay out here.&lt;/p&gt;

&lt;p&gt;
Heading into 2017, the new project I want to tackle is learning to write code in &lt;a href=&#34;https://golang.org/&#34;&gt;Go&lt;/a&gt;. Here are the 5 strategies I&amp;rsquo;ve started using to reach that goal:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Attend live events, like the &lt;a href=&#34;https://twitter.com/framinghamgo&#34;&gt;Framingham Go Meetup&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Read in-depth books, like &lt;a href=&#34;https://www.manning.com/books/go-in-action&#34;&gt;Go in Action&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Do lots of coding exercises,  like &lt;a href=&#34;https://gobyexample.com/&#34;&gt;Go by Example&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Make a mini project that puts these new concepts to use (coming soon)&lt;/li&gt;
&lt;li&gt;Contribute to one of our live Go projects at work (The Big Goal)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;It might seem like a scattershot approach, but having 5 different ways to come in contact with a new language has two layers of benefits: the things I learn directly in each context and the things that get woven together as a result of switching context between each approach.&lt;/p&gt;

&lt;p&gt;Here are the &amp;ldquo;direct&amp;rdquo; and &amp;ldquo;crossover&amp;rdquo; benefits of each strategy:&lt;/p&gt;

&lt;h2 id=&#34;attending-live-events&#34;&gt;Attending Live Events&lt;/h2&gt;

&lt;p&gt;I wandered into my first &lt;a href=&#34;https://twitter.com/framinghamgo&#34;&gt;Framingham Go Meetup&lt;/a&gt; with almost no exposure to Go, which is what I did with Ruby a few years ago. A little intimidating? Yes. Did I feel out of place? Yup. Were people welcoming and friendly? Yes!&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Direct benefits:&lt;/strong&gt; Knowing full well that I would only understand bits and pieces of the talks at the first meetup, I still went for two reasons.&lt;/p&gt;

&lt;p&gt;Now I have a benchmark for seeing progress &amp;ndash; in 6 months, maybe I&amp;rsquo;ll think, &amp;ldquo;hey, I understood 70% of the talks this month!&amp;rdquo;&lt;/p&gt;

&lt;p&gt;By meeting people and hearing about what they are working on and how they tackle problems with Go, I can start to think about applications and business logic I already understand through a Go lens.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Crossover benefits:&lt;/strong&gt; Fully embracing the discomfort of being in a place where some part of you thinks you don&amp;rsquo;t belong prepares you for taking on unknowns in every other mode of learning too.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bonus:&lt;/strong&gt; I got to hear directly from Bill Kennedy (&lt;a href=&#34;http://twitter.com/goinggodotnet&#34;&gt;@goinggodotnet&lt;/a&gt;), the author of Go in Action, which I had just started reading. Big Thanks for speaking to the group and sharing &lt;a href=&#34;https://github.com/ardanlabs/gotraining/blob/master/reading/README.md&#34;&gt;these excellent resources&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;reading-books&#34;&gt;Reading Books&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Direct benefits:&lt;/strong&gt; Without previous experience in statically typed, compiled programming languages, there&amp;rsquo;s a lot about Go that I just don&amp;rsquo;t have exposure to. Having the background explained thoroughly in the long format of a book like &lt;a href=&#34;https://www.manning.com/books/go-in-action&#34;&gt;Go in Action&lt;/a&gt; is really helpful, even if I know I&amp;rsquo;m not going to retain everything on the first read.&lt;/p&gt;

&lt;p&gt;As far as programming concepts go too, the explicit format of the book helps highlight places where I do know what&amp;rsquo;s going on and I can draw comparisons to languages I already know.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Crossover benefits:&lt;/strong&gt; In the last year, I&amp;rsquo;ve really recognized that if I&amp;rsquo;m actively reading a book on programming concepts, then I&amp;rsquo;m sharper every day when I go to code. I &lt;em&gt;think&lt;/em&gt; this has to do with building better mental models about the work. As little as 10-15 minutes of theory reading a day helps me think more clearly about problems I&amp;rsquo;m trying to solve, even if they are unrelated to the book I&amp;rsquo;m reading.&lt;/p&gt;

&lt;h2 id=&#34;coding-exercises&#34;&gt;Coding Exercises&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Direct benefits:&lt;/strong&gt; While coding books do tend to have examples in them, I find a ton of added benefit to sites like &lt;a href=&#34;https://gobyexample.com/&#34;&gt;Go by Example&lt;/a&gt;, where you can do exercise after exercise. I&amp;rsquo;m not necessarily talking about &amp;ldquo;coding challenges&amp;rdquo; either. Instead, I want to find examples that I can literally copy to reinforce the patterns and idioms used in Go. Rote learning here is tremendously helpful to get my fingers to start &amp;ldquo;thinking in Go.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Crossover benefits:&lt;/strong&gt; After a while, I start jumping back and forth between books and exercises, to create stronger connections between the muscle memory in my hands and the concepts in my head.&lt;/p&gt;

&lt;p&gt;For example, once I read the section on loops and conditionals, I thought, why not try Fizzbuzz:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
	for i := 1; i &amp;lt;= 100; i++ {
		if i%15 == 0 {
			fmt.Println(&amp;quot;fizzbuzz&amp;quot;)
		} else if i%5 == 0 {
			fmt.Println(&amp;quot;buzz&amp;quot;)
		} else if i%3 == 0 {
			fmt.Println(&amp;quot;fizz&amp;quot;)
		} else {
			fmt.Println(i)
		}

	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;From past experience with simple code exercises in other languages, I know that I&amp;rsquo;ll reimplement Fizzbuzz or something like it &amp;ndash; maybe with goroutines and channels?? &amp;ndash; a half dozen times over the next few months, as I pick up new concepts and styles.&lt;/p&gt;

&lt;h2 id=&#34;mini-projects&#34;&gt;Mini Projects&lt;/h2&gt;

&lt;p&gt;I actually started out thinking this was the first thing I would do. Pretty soon, though, I realized that I&amp;rsquo;d rather get a foundation in the core concepts first and have some muscle memory, i.e. not have to look up the syntax for declaring variables or iterating over a slice.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Direct benefits:&lt;/strong&gt; By pushing this project back a little bit, I can use it as a test of &amp;ldquo;the basics.&amp;rdquo; Also, for what I have in mind (stay tuned!), I will need to dig into Go&amp;rsquo;s standard library for things like making http requests and file IO. I&amp;rsquo;m considering these slightly more advanced explorations, once I feel comfortable with the flow of a simple program.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Crossover benefits:&lt;/strong&gt; Hopefully, this stage will push me to ask some bigger design questions too and I&amp;rsquo;ll have the chance to talk to my coworkers or people I&amp;rsquo;ve met from the meetups more about that.&lt;/p&gt;

&lt;h2 id=&#34;production-code-at-work&#34;&gt;Production Code at Work&lt;/h2&gt;

&lt;p&gt;This is on my strategy list, but it&amp;rsquo;s really a goal that will prove that I&amp;rsquo;ve done the work of all the other strategies.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Direct benefits:&lt;/strong&gt; Not only would some production code be higher stakes than code I&amp;rsquo;d write in any of the other approaches &amp;ndash; nothing like production deployment pressure to accelerate learning! &amp;ndash; but I will also have the most context, because I&amp;rsquo;ve been writing code for the same platform, so I&amp;rsquo;ll have lots of domain knowledge to guide me.&lt;/p&gt;

&lt;p&gt;At Tapjoy, we&amp;rsquo;ve successfully ported portions of multiple Rails applications to Go services that run much more performantly. I have my eye on one particular area that I think could also benefit from a Go re-write. Aiming towards a working version of that application in Go in my spare time will be a great capstone for this entire learning process.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Be sure to check back next December for &amp;ldquo;5 Improved Strategies for Really Learning Go, This Time, I Swear, in 2018&amp;rdquo;.&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>